<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FaithTech Community Map</title>
  <style>
    body {
      margin: 0;
      background-color: white;
      font-family: 'Inter', sans-serif;
      text-align: center;
    }
    h1 {
      margin-top: 1em;
    }
    svg {
      width: 90vw;
      height: 80vh;
      margin: auto;
      display: block;
    }
    #map-container {
      background-color: white;
    }
    #controls {
      margin: 1em;
      display: flex;
      flex-wrap: wrap; /* Allow wrapping on smaller screens */
      justify-content: center;
      align-items: center;
      gap: 20px;
    }
    #download-buttons {
      margin: 1em;
    }
    /* This rule is now a fallback, inline styles will take precedence */
    .pin path {
      stroke: black;
      stroke-width: 15;
      opacity: 0.95;
      filter: url(#pinShadow);
    }
    #legend {
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      text-anchor: start;
      pointer-events: none; /* Make legend non-interactive with zoom */
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
    }
    .legend-color {
      width: 16px;
      height: 16px;
      margin-right: 8px;
      border-radius: 50%;
    }
    .legend-label {
      color: black;
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/topojson-client@3"></script>
</head>
<body>
  <h1>FaithTech Community Map</h1>
  <input type="file" id="csvUpload" accept=".csv" />
  <div id="controls">
    <div>
      <label><input type="radio" name="projectionType" value="mercator" checked> Mercator</label>
      <label><input type="radio" name="projectionType" value="equalEarth"> Equal Earth</label>
    </div>
    <div>
      <label for="color-selector">Current City Color: </label>
      <select id="color-selector">
        <option value="#FFF737">Yellow 100</option>
        <option value="#FFD700">Yellow 200</option>
        <option value="#FFB300">Orange 100</option>
        <option value="#F05228" selected>Orange 200</option>
        <option value="#BAE386">Green 100</option>
        <option value="#32A432">Green 200</option>
        <option value="#8ADFFF">Blue 100</option>
        <option value="#1D8FB9">Blue 200</option>
      </select>
    </div>
  </div>
  <div id="map-container"></div>
  <div id="download-buttons">
    <button onclick="downloadSVG()">Download SVG</button>
    <button onclick="downloadPNG()">Download PNG</button>
  </div>

  <script>
    let currentCityColor = "#F05228";
    const potentialCityColor = "#CDCDCD";
    let cityData = null; // To store uploaded data

    const width = 960;
    const height = 500;

    const svg = d3.select("#map-container")
      .append("svg")
      .attr("viewBox", `0 0 ${width} ${height}`)
      .attr("preserveAspectRatio", "xMidYMid meet");


    const defs = svg.append("defs");
    const filter = defs.append("filter")
      .attr("id", "pinShadow")
      .attr("x", "-50%")
      .attr("y", "-50%")
      .attr("width", "200%")
      .attr("height", "200%");

    filter.append("feDropShadow")
      .attr("dx", "0")
      .attr("dy", "1")
      .attr("stdDeviation", "1.5")
      .attr("flood-color", "rgba(0, 0, 0, 0.5)");

    let projection;
    let path;
    let land;
    let g; // Group for map elements to handle zoom/pan

    const zoom = d3.zoom()
      .scaleExtent([1, 8])
      .on("zoom", (event) => {
        g.attr("transform", event.transform);
      });

    svg.call(zoom);
    g = svg.append("g");

    d3.json("https://unpkg.com/world-atlas@2.0.2/countries-110m.json").then(worldData => {
      land = topojson.feature(worldData, worldData.objects.countries);
      setProjection("mercator");
      renderMap();
    });

    document.querySelectorAll("input[name='projectionType']").forEach(input => {
      input.addEventListener("change", function() {
        setProjection(this.value);
        renderMap();
        if (cityData) {
            plotPoints(cityData);
        }
      });
    });

    document.getElementById("color-selector").addEventListener("change", function(evt) {
        currentCityColor = evt.target.value;
        if (cityData) {
            plotPoints(cityData);
        }
    });

    function setProjection(type) {
      if (type === "equalEarth") {
        projection = d3.geoEqualEarth()
          .scale(160)
          .translate([width / 2, height / 2]);
      } else {
        projection = d3.geoMercator()
          .scale(130)
          .translate([width / 2, height / 1.45]);
      }
      path = d3.geoPath().projection(projection);
    }

    function renderMap() {
      g.selectAll("path.country").remove();
      g.insert("g", ".pin")
        .selectAll("path")
        .data(land.features)
        .enter().append("path")
        .attr("class", "country")
        .attr("fill", "#333")
        .attr("stroke", "#fff")
        .attr("stroke-width", 0.5)
        .attr("d", path);
    }

    document.getElementById("csvUpload").addEventListener("change", function(evt) {
      const file = evt.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        cityData = d3.csvParse(e.target.result);
        plotPoints(cityData);
      };
      reader.readAsText(file);
    });

    function plotPoints(data) {
      g.selectAll(".pin").remove();
      svg.selectAll("#legend").remove();

      const pinPath = "M352 348.4C416.1 333.9 464 276.5 464 208C464 128.5 399.5 64 320 64C240.5 64 176 128.5 176 208C176 276.5 223.9 333.9 288 348.4L288 544C288 561.7 302.3 576 320 576C337.7 576 352 561.7 352 544L352 348.4zM328 160C297.1 160 272 185.1 272 216C272 229.3 261.3 240 248 240C234.7 240 224 229.3 224 216C224 158.6 270.6 112 328 112C341.3 112 352 122.7 352 136C352 149.3 341.3 160 328 160z";

      const normalizedData = data.filter(d => {
        return d.Latitude && d.Longitude && !isNaN(+d.Latitude) && !isNaN(+d.Longitude);
      }).map(d => ({
        ...d,
        normalizedStatus: (d["Map Status"] || "").trim().toLowerCase()
      }));

      const potentialCities = normalizedData.filter(d => d.normalizedStatus !== "current city" && d.normalizedStatus !== "active");
      const currentCities = normalizedData.filter(d => d.normalizedStatus === "current city" || d.normalizedStatus === "active");

      const uniqueCountries = (arr) => new Set(arr.map(d => (d.Country || '').trim())).size;

      g.append("g")
        .selectAll("g.pin")
        .data(potentialCities)
        .enter()
        .append("g")
        .attr("class", "pin")
        .attr("transform", d => {
          const [x, y] = projection([+d.Longitude, +d.Latitude]);
          if (!x || !y) return "translate(0,0) scale(0)";
          return `translate(${x},${y}) scale(0.03) translate(-320, -576)`;
        })
        .append("path")
        .attr("d", pinPath)
        .attr("fill", potentialCityColor)
        // FIXED: Added inline styles for SVG export
        .style("stroke", "black")
        .style("stroke-width", 15);

      g.append("g")
        .selectAll("g.pin")
        .data(currentCities)
        .enter()
        .append("g")
        .attr("class", "pin")
        .attr("transform", d => {
          const [x, y] = projection([+d.Longitude, +d.Latitude]);
          if (!x || !y) return "translate(0,0) scale(0)";
          return `translate(${x},${y}) scale(0.05) translate(-320, -576)`;
        })
        .append("path")
        .attr("class", "current-city-pin")
        .attr("d", pinPath)
        .attr("fill", currentCityColor)
        // FIXED: Added inline styles for SVG export
        .style("stroke", "black")
        .style("stroke-width", 15);

      const legendCoordinates = [-49.27127240, -38.0054771]; // [Longitude of Curitiba, Latitude of Mar Del Plata]
      const [legendX, legendY] = projection(legendCoordinates);

      const legend = svg.append("g")
        .attr("id", "legend")
        .attr("transform", `translate(${legendX}, ${legendY})`);

      const legendItems = [
        {
          color: currentCityColor,
          label: `${currentCities.length} Cities Across ${uniqueCountries(currentCities)} Countries`,
          isCurrent: true
        },
        {
          color: potentialCityColor,
          label: `${potentialCities.length} Potential Future Cities Across ${uniqueCountries(potentialCities)} Countries`,
          isCurrent: false
        }
      ];
      
      legend.append("rect")
        .attr("x", -10)
        .attr("y", -15)
        .attr("width", 330)
        .attr("height", 55)
        .attr("fill", "rgba(255, 255, 255, 0.8)")
        .attr("rx", 8);

      legendItems.forEach((item, i) => {
        const group = legend.append("g").attr("transform", `translate(0, ${i * 24})`);
        group.append("path")
          .attr("class", item.isCurrent ? "current-city-legend-pin" : "")
          .attr("d", pinPath)
          .attr("transform", "scale(0.04) translate(-320, -576)")
          .attr("fill", item.color)
          .style("stroke", "black")
          .style("stroke-width", 15);

        group.append("text")
          .attr("x", 25)
          .attr("y", -5)
          .attr("fill", "black")
          .style("font-weight", "bold")
          .text(item.label);
      });
    }

    // UPDATED: Function to embed styles for download
    function embedStylesForDownload(callback) {
        const styles = `
            @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
            #legend text {
                font-family: 'Inter', sans-serif;
                font-size: 14px;
                font-weight: bold;
                fill: black;
            }
        `;
        const styleElement = defs.append("style").text(styles);
        
        // Allow browser time to fetch and apply font
        setTimeout(() => {
            callback();
            styleElement.remove();
        }, 500);
    }

    function downloadSVG() {
        embedStylesForDownload(() => {
            const originalTransform = g.attr("transform");
            g.attr("transform", "");

            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(svg.node());
            const blob = new Blob([svgString], {type: "image/svg+xml;charset=utf-8"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "faithtech-map.svg";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            g.attr("transform", originalTransform);
        });
    }

    function downloadPNG() {
        embedStylesForDownload(() => {
            const originalTransform = g.attr("transform");
            g.attr("transform", "");

            const svgString = new XMLSerializer().serializeToString(svg.node());
            const canvas = document.createElement("canvas");
            canvas.width = width * 2; // Higher resolution for PNG
            canvas.height = height * 2;
            const ctx = canvas.getContext("2d");

            const img = new Image();
            const svgBlob = new Blob([svgString], {type: "image/svg+xml;charset=utf-8"});
            const url = URL.createObjectURL(svgBlob);

            img.onload = () => {
                ctx.fillStyle = "white";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                URL.revokeObjectURL(url);

                const pngURL = canvas.toDataURL("image/png");
                const a = document.createElement("a");
                a.href = pngURL;
                a.download = "faithtech-map.png";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                g.attr("transform", originalTransform);
            };
            img.src = url;
        });
    }
  </script>
</body>
</html>

